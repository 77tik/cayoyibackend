package csvreader

import (
	"bytes"
	"encoding/csv"
	"github.com/zeromicro/go-zero/core/logx"
	"io"
	"os"
	"strconv"
)

// è¯»å–excelæ–‡ä»¶ï¼Œä»…ä»…åªæ˜¯ç”¨csv åŒ…è£…ä¸€ä¸‹readerå°±å¯ä»¥

// BOM çš„å…¨ç§°æ˜¯ï¼š
//
//Byte Order Markï¼ˆå­—èŠ‚é¡ºåºæ ‡è®°ï¼‰
//
//å®ƒæ˜¯ æ–‡ä»¶å¼€å¤´çš„ç‰¹æ®Šéšè—å­—ç¬¦ï¼Œç”¨æ¥è¯´æ˜æ–‡æœ¬çš„ç¼–ç æ ¼å¼ï¼ˆæ¯”å¦‚ UTF-8ã€UTF-16 ç­‰ï¼‰ã€‚
//ğŸ“¦ UTF-8 ä¸­çš„ BOM é•¿è¿™æ ·ï¼š
//3 ä¸ªå­—èŠ‚ï¼ˆåå…­è¿›åˆ¶ï¼‰ï¼š
//EF BB BF
//åè¿›åˆ¶æ˜¯ï¼š
//239 187 191
//ä½ å¹³æ—¶çœ‹ä¸åˆ°å®ƒï¼Œä½†å®ƒå°±å·å·è—åœ¨æ–‡ä»¶æœ€å¼€å¤´ï¼

// æ£€æŸ¥å¹¶è·³è¿‡BOM
func skipBOM(r io.Reader) io.Reader {
	buf := make([]byte, 3)
	n, err := r.Read(buf)
	if err != nil || n < 3 {
		return r
	}
	// UTF-8 BOM æ˜¯ 0xEF, 0xBB, 0xBF
	if buf[0] == 0xEF && buf[1] == 0xBB && buf[2] == 0xBF {
		return r
	}

	// å¦‚æœä¸æ˜¯ BOMï¼Œå°±å°†è¯»å–çš„å­—èŠ‚é‡æ–°æ”¾å›
	// æ„é€ ä¸€ä¸ªæ–°çš„ Readerï¼Œå®ƒçš„å†…å®¹ç­‰äºï¼šå…ˆè¯» buf çš„å†…å®¹ï¼Œå†ç»§ç»­è¯» r é‡Œçš„å†…å®¹
	// ä¹Ÿå°±æ˜¯æŠŠ buf + r æ‹¼æˆä¸€ä¸ªæ–°çš„æµã€‚
	return io.MultiReader(bytes.NewReader(buf), r)
}

// ReadCsvResultï¼Œè¯»å–å…·æœ‰å¦‚ä¸‹æ ¼å¼çš„CSVæ–‡ä»¶
// å¦‚æ±›æœŸæ°´æ–‡æ¨¡å‹çš„ç»“æœæ–‡ä»¶asin_Q_10days.csvï¼š
// ä¹ä»™æ±¤æ²³,å›´é‡Œæ°´,ä¹Œå²—æ²³,ä¸‡åŸ æ°´,å®è²æ°´,é¾™æºªæ²³,é»„æ²™æ¸¯,åŒ—æ½¦æ²³ä¸Šæ¸¸,å—æ½¦æ²³ä¸Šæ¸¸,é¾™å®‰æ²³,å¡”é‡Œæ²³,ä»°å±±æ²³,å—æ½¦æ²³åŒºé—´4,å—æ½¦æ²³åŒºé—´3,å—æ½¦æ²³åŒºé—´2,å—æ½¦æ²³åŒºé—´1,æ½¦æ²³åŒºé—´2,æ½¦æ²³åŒºé—´1,åŒ—æ½¦æ²³åŒºé—´3,åŒ—æ½¦æ²³åŒºé—´2,åŒ—æ½¦æ²³åŒºé—´1,åŒ—æ²³åŒºé—´2,åŒ—æ²³åŒºé—´1,ç½—æ¹¾æ°´åº“åŒºé—´,æ°´æ‹¦å…³æ°´åº“åŒºé—´,é¦™åªæ°´åº“åŒºé—´,å°æ¹¾æ°´åº“åŒºé—´,æ´ªå±ç”µç«™åŒºé—´
// 34.85040331454639,24.928075321338255,29.826139235232404,21.847922115490668,6.504095823057907,58.335834072797255,85.5421898085348,63.69920757603363,135.36345263357998,133.9315631179018,28.306031541687812,23.436926039220776,41.06872847613935,206.9569228810641,88.19888563519856,49.46689883185629,94.60907994431975,98.77599069579189,50.30272877905033,98.20208250811557,67.3628365448744,30.98578491689644,59.980297929277285,65.270757343608,19.165335749469886,9.980960833192903,31.813223283331705,103.14149130995395
// 34.798360452137516,25.0031408072659,29.813165691910832,21.856619882847557,6.500546820546196,58.39673837016586,85.62082769603191,63.731904577275735,135.72761360543694,133.92830184323677,28.361962830474102,23.454771620782605,41.074252372951264,206.8472802419509,88.32212494418852,49.44883876435341,94.55603490637228,98.94511454990914,50.39295712281673,98.41680528379084,67.44889269678639,30.91023681542022,60.000269517345934,65.36526615292699,19.184616962922746,9.978910793889277,31.811429889656793,103.12192142904175
// 34.8043493193295,25.03426510418999,29.78217974352207,21.831301911788252,6.507026663047113,58.41163281736383,85.69108072070416,63.680023463074946,135.82096127156402,133.79788583809855,28.410185678936546,23.467461418935205,41.114053482263124,206.74454987218587,88.41987155808195,49.390918005890185,94.48147095392513,99.00453106369046,50.462645597317696,98.53585172546805,67.51604702416908,30.829604523656464,60.00552355258726,65.36572064062331,19.205230632020783,9.987504587262782,31.77152043877742,102.97978801234868
// 34.79518684623786,25.10671212671475,29.794699532226538,21.8081768103469,6.506148379375513,58.50136132333529,85.82218034691608,63.62064587136432,135.9166926406368,133.8571292737299,28.47515508718268,23.503381727611355,41.1145258565401,206.7507230908309,88.52228596031765,49.36318947412948,94.50732892192119,99.07439217396748,50.51587026496601,98.74754212743277,67.5202446370954,30.770521280332915,59.98428669621918,65.39755487654449,19.217806780198007,9.991838186432844,31.731954616734136,102.88385749041376
func ReadCsv(fileName string) (map[string][]float64, error) {
	open, err := os.Open(fileName)
	if err != nil {
		return nil, err
	}
	defer func() { _ = open.Close() }()

	// è·³è¿‡BOM
	reader := skipBOM(open)

	csvReader := csv.NewReader(reader)
	// è¿”å›æ¯ä¸€è¡Œçš„å†…å®¹
	all, err := csvReader.ReadAll()
	if err != nil {
		return nil, err
	}
	var res = make(map[string][]float64)
	header := all[0] // ç¬¬ä¸€è¡Œå°±æ˜¯æ°´åº“å
	for lIdx, line := range all[1:] {
		for i, v := range header {
			if _, ok := res[v]; !ok {
				res[v] = make([]float64, 0)
			}

			val, err := strconv.ParseFloat(line[i], 64)
			if err != nil {
				logx.Errorf("file:%s, header name:%s, line idx(base 0):%d,strconv.ParseFloat error: %v", fileName, v, lIdx+1, err)
				return nil, err
			}
			res[v] = append(res[v], val)
		}
	}

	return res, nil
}
